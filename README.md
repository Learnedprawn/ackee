# Ackee
# 🔐 Program Derived Addresses (PDAs) in Solana Anchor

## 🧠 What is a PDA?

A **PDA (Program Derived Address)** is a **special public key** generated by a program, which is **owned and controlled by the program itself** — not by any external user or private key.

It is **deterministic** — meaning, the same input (`seeds + program ID`) will always generate the same address.

### ✅ Why use PDAs?
- To create **program-owned accounts** that users can't manually sign for or modify.
- For securely managing:
  - Vaults
  - User profiles
  - Metadata
  - Escrow accounts
  - Game states

---

## 🛠️ PDA Creation: Side-by-Side

### 📍 1. PDA Validation in Anchor

```rust
#[derive(Accounts)]
pub struct MyInstruction<'info> {
    #[account(
        seeds = [b"vault", user.key().as_ref()],
        bump
    )]
    pub vault: Account<'info, Vault>,

    pub user: Signer<'info>,
}

#[account(
    init,
    payer = user,
    space = 8 + 32,
    seeds = [b"vault", user.key().as_ref()],
    bump
)]
pub vault: Account<'info, Vault>,
``````

### 🍝 Analogy
Imagine you're a program chef making dishes for users. Instead of using random dish IDs, you use a recipe:
```

Dish ID = hash("pasta" + customer_public_key + program_id)
```
This ensures:

The dish always goes to the right customer

Only you (the chef/program) can cook, modify, or serve the dish

Customers can’t mess with your recipes — no rogue spaghetti

# 📘 Understanding PDA Bumps in Solana Anchor

## 🔹 What is a **bump**?

When you create a **Program Derived Address (PDA)** using:

```rust
Pubkey::find_program_address(seeds, program_id)
```

Solana automatically finds a **bump seed** (a `u8`) that, when added to your seeds, generates a valid PDA **off the ed25519 curve**. This ensures:

* The address can't be owned by a private key.
* It is safe for **programs** to sign with.

### ✅ TL;DR:

> A **bump** is a small number (`u8`) added to your seeds to make your PDA valid and secure.

---

## 🔹 Why does **Anchor** care about bumps?

When doing **Cross-Program Invocations (CPIs)** using `with_signer`, you need to **recompute the PDA exactly**, including the bump.

If you miss the bump, you’ll face errors like:

```text
Cross-program invocation with unauthorized signer or writable account.
```

Basically, without the correct bump, Anchor can’t "prove" it’s authorized to act as that PDA.

---

## 🔹 Where does `ctx.bumps.<name>` come from?

In Anchor, when you define a PDA like this:

```rust
#[account(
    mut,
    seeds = [b"vault", vault_authority.key().as_ref()],
    bump
)]
pub vault: Account<'info, Vault>,
```

Anchor:

* Automatically calculates the bump.
* Stores it in `ctx.bumps.vault` (because the account field is named `vault`).
* You **don’t** need to call `find_program_address` manually.

---

## 🔹 Example usage of bump in `signer_seeds`

When you want to sign something **as your PDA**, use the bump like so:

```rust
let signer_seeds = &[
    b"vault",
    ctx.accounts.vault_authority.key.as_ref(),
    &[ctx.bumps.vault], // 👈 Bump goes here!
];

let signer = &[&signer_seeds[..]];
```

Then pass `signer` to any CPI or account instruction that needs to sign as the PDA.

---

## 🔹 Summary

| Concept                      | Explanation                                    |
| ---------------------------- | ---------------------------------------------- |
| **Bump**                     | A `u8` used to create valid, non-signable PDAs |
| **`ctx.bumps.<field_name>`** | Anchor auto-stores the bump for each PDA       |
| **Why needed?**              | Required when signing CPIs using `with_signer` |

---

Anchor handles a lot under the hood — you just need to remember to use the bump when signing with PDAs!

---

